# README
## 本项目是北邮信安专业操作系统的课程设计，是在30天自制操作系统的代码基础上加工而成的。<br/> 
下面给出本次课程设计的要求：<br/> 
1.依据30天实验中使用LDT结构的用户程序版本，设计、实现并展示用户程序中变量的逻辑地址到实际物理地址的转换（只有分段，没有分页）<br/> 
2.在操作系统内核设计并实现进程访问共享变量时的竞争条件<br/> 
3.在操作系统内核态设计并实现竞争条件的解决方案（两进程、多进程），
并进一步实现某个同步场景（生产者消费者、读者作者等） 必做，至少一个解决方案，至少一个同步场景<br/> 
4.设计并实现从用户态启动内核态竞争条件、解决方案、同步场景（练习系统调用）<br/> 
5.设计并实现用户态的竞争条件、解决方案和同步场景<br/> 
6.设计并实现新的内存分配算法，并在系统中验证<br/> 
<br/> 
`说明`：<br/> 
### 1.<br/> 
30天自制操作系统上只有分段，没有分页。首先，GDT（全局段描述符)的基地址是0x270000，30天规定了GDT的1-2号，也就是头2个条目归dsctbl.c文件使用，<br/> 
而任务所用的起始段号为3，因为规定了最多只能申请100个任务，所以3-102都是任务的GDT条目(存储tss32结构体)，<br/> 
对应地，从103-202是每个任务对应的ldtr的地址。因为在这个操作系统中，任务只用到了数据段和代码段2个段，<br/> 
所以每个任务的ldt仅有2个项目,每个ldt项目有16位的段选择子，如下图：<br/> 
![image](https://github.com/willinin/30days-os/blob/master/picture/selector.png)<br/> 
那么首先，我们通过task的GDT条目，找到任务ldtr的起始地址(tss.ldtr),其实也是个段描述符<br/>
ldtr+0为代码段，ldtr+1为数据段，那么通过这个段的index（索引量）+段基址可以得到线性基地址。<br/>
(这里需要注意的是段地址和段基址不是同一个概念，段地址保存着段基址和段上限等信息)。<br/>
那么，物理地址=线性基地址+逻辑地址<br/>
段地址保存的64位信息如下：<br/>
![image](https://github.com/willinin/30days-os/blob/master/picture/1.png)<br/> 
### 2.<br/> 
要在内核态体现竞争条件，这里的设计思路是在内核态增加一个int型的共享变量，2个进程不断地轮流对这个变量做+1操作。<br/> 
在正常情况下，一个进程执行了对共享变量+1操作后，其和操作之前的差应该是1，如果差值大于1的话，说明存在其他进程，<br/> 
在这个进程执行+1操作时，访问了这个共享变量并做了运算，那么此时就表现出了竞争条件。<br/> 
### 3.<br/> 
2个场景及其解决方案都有实现。（根据操作系统的书）
在内核态上，用peterson算法解决了生产者和消费者的竞争条件，用信号量解决了读者和作者的竞争条件。<br/> 
需要注意的是peterson算法只能解决2个进程间的同步问题，所以读者和作者的竞争条件用peterson算法是不可行的。<br/> 
### 4.<br/>
到这里需要注意的是一个任务在内核态中，如果进入无限while循环，且不执行有意义的操作，那么该任务会自动休眠，等待被唤醒，
如果不想其被休眠，要强制改变任务状态。<br/> 
此操作系统没有进程的概念，只有任务，可以认为一个任务就是一个进程。<br/> 
注册api，so easy。<br/> 
### 5.<br/> 
这里设计了一些数据结构及函数，在svar.c中有所体现。此外，还实现了test_and_set互斥锁。<br/> 
### 6.<br/> 
此操作系统实现的是内存的连续分配，且找到第一个可用的内存块即分配，比较投机取巧的方法是设计最优匹配，或者使用buddy算法。
